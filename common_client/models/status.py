# coding: utf-8

"""
    APIs OpenData do Open Banking Brasil

    As APIs descritas neste documento são referentes as APIs da fase OpenData do Open Banking Brasil.  # noqa: E501

    OpenAPI spec version: 1.0.0-rc5.2
    Contact: apiteam@swagger.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Status(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'code': 'str',
        'explanation': 'str',
        'detection_time': 'str',
        'expected_resolution_time': 'str',
        'update_time': 'str',
        'unavailable_endpoints': 'list[str]'
    }

    attribute_map = {
        'code': 'code',
        'explanation': 'explanation',
        'detection_time': 'detectionTime',
        'expected_resolution_time': 'expectedResolutionTime',
        'update_time': 'updateTime',
        'unavailable_endpoints': 'unavailableEndpoints'
    }

    def __init__(self, code=None, explanation=None, detection_time=None, expected_resolution_time=None, update_time=None, unavailable_endpoints=None):  # noqa: E501
        """Status - a model defined in Swagger"""  # noqa: E501
        self._code = None
        self._explanation = None
        self._detection_time = None
        self._expected_resolution_time = None
        self._update_time = None
        self._unavailable_endpoints = None
        self.discriminator = None
        self.code = code
        self.explanation = explanation
        if detection_time is not None:
            self.detection_time = detection_time
        if expected_resolution_time is not None:
            self.expected_resolution_time = expected_resolution_time
        if update_time is not None:
            self.update_time = update_time
        if unavailable_endpoints is not None:
            self.unavailable_endpoints = unavailable_endpoints

    @property
    def code(self):
        """Gets the code of this Status.  # noqa: E501

        Condição atual da API:   * `OK` - A implementação é totalmente funcional   * `PARTIAL_FAILURE` - Um ou mais endpoints estão indisponíveis   * `UNAVAILABLE` - A implementação completa está indisponível   * `SCHEDULED_OUTAGE` - Uma interrupção anunciada está em vigor   # noqa: E501

        :return: The code of this Status.  # noqa: E501
        :rtype: str
        """
        return self._code

    @code.setter
    def code(self, code):
        """Sets the code of this Status.

        Condição atual da API:   * `OK` - A implementação é totalmente funcional   * `PARTIAL_FAILURE` - Um ou mais endpoints estão indisponíveis   * `UNAVAILABLE` - A implementação completa está indisponível   * `SCHEDULED_OUTAGE` - Uma interrupção anunciada está em vigor   # noqa: E501

        :param code: The code of this Status.  # noqa: E501
        :type: str
        """
        if code is None:
            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
        allowed_values = ["OK", "PARTIAL_FAILURE", "UNAVAILABLE", "SCHEDULED_OUTAGE"]  # noqa: E501
        if code not in allowed_values:
            raise ValueError(
                "Invalid value for `code` ({0}), must be one of {1}"  # noqa: E501
                .format(code, allowed_values)
            )

        self._code = code

    @property
    def explanation(self):
        """Gets the explanation of this Status.  # noqa: E501

        Fornece uma explicação da interrupção atual que pode ser exibida para um cliente final. Será obrigatoriamente preenchido se code tiver algum valor que não seja OK  # noqa: E501

        :return: The explanation of this Status.  # noqa: E501
        :rtype: str
        """
        return self._explanation

    @explanation.setter
    def explanation(self, explanation):
        """Sets the explanation of this Status.

        Fornece uma explicação da interrupção atual que pode ser exibida para um cliente final. Será obrigatoriamente preenchido se code tiver algum valor que não seja OK  # noqa: E501

        :param explanation: The explanation of this Status.  # noqa: E501
        :type: str
        """
        if explanation is None:
            raise ValueError("Invalid value for `explanation`, must not be `None`")  # noqa: E501

        self._explanation = explanation

    @property
    def detection_time(self):
        """Gets the detection_time of this Status.  # noqa: E501

        A data e hora em que a interrupção atual foi detectada. Será obrigatoriamente preenchido se a propriedade code for PARTIAL_FAILURE ou UNAVAILABLE  # noqa: E501

        :return: The detection_time of this Status.  # noqa: E501
        :rtype: str
        """
        return self._detection_time

    @detection_time.setter
    def detection_time(self, detection_time):
        """Sets the detection_time of this Status.

        A data e hora em que a interrupção atual foi detectada. Será obrigatoriamente preenchido se a propriedade code for PARTIAL_FAILURE ou UNAVAILABLE  # noqa: E501

        :param detection_time: The detection_time of this Status.  # noqa: E501
        :type: str
        """

        self._detection_time = detection_time

    @property
    def expected_resolution_time(self):
        """Gets the expected_resolution_time of this Status.  # noqa: E501

        A data e hora em que o serviço completo deve continuar (se conhecido). Será obrigatoriamente preenchido se code tiver algum valor que não seja OK  # noqa: E501

        :return: The expected_resolution_time of this Status.  # noqa: E501
        :rtype: str
        """
        return self._expected_resolution_time

    @expected_resolution_time.setter
    def expected_resolution_time(self, expected_resolution_time):
        """Sets the expected_resolution_time of this Status.

        A data e hora em que o serviço completo deve continuar (se conhecido). Será obrigatoriamente preenchido se code tiver algum valor que não seja OK  # noqa: E501

        :param expected_resolution_time: The expected_resolution_time of this Status.  # noqa: E501
        :type: str
        """

        self._expected_resolution_time = expected_resolution_time

    @property
    def update_time(self):
        """Gets the update_time of this Status.  # noqa: E501

        A data e hora em que esse status foi atualizado pela última vez pelo titular dos dados.  # noqa: E501

        :return: The update_time of this Status.  # noqa: E501
        :rtype: str
        """
        return self._update_time

    @update_time.setter
    def update_time(self, update_time):
        """Sets the update_time of this Status.

        A data e hora em que esse status foi atualizado pela última vez pelo titular dos dados.  # noqa: E501

        :param update_time: The update_time of this Status.  # noqa: E501
        :type: str
        """

        self._update_time = update_time

    @property
    def unavailable_endpoints(self):
        """Gets the unavailable_endpoints of this Status.  # noqa: E501

        Endpoints com indisponibilidade  # noqa: E501

        :return: The unavailable_endpoints of this Status.  # noqa: E501
        :rtype: list[str]
        """
        return self._unavailable_endpoints

    @unavailable_endpoints.setter
    def unavailable_endpoints(self, unavailable_endpoints):
        """Sets the unavailable_endpoints of this Status.

        Endpoints com indisponibilidade  # noqa: E501

        :param unavailable_endpoints: The unavailable_endpoints of this Status.  # noqa: E501
        :type: list[str]
        """

        self._unavailable_endpoints = unavailable_endpoints

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Status, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Status):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
